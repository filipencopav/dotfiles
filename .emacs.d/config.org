#+STARTUP: CONTENT

* Requires
** Load path
   #+begin_src emacs-lisp
     (eval-when-compile
       (add-to-list 'load-path (expand-file-name "~/.emacs.d/elisp/")))
   #+end_src

** Common Lisp library
   #+begin_src emacs-lisp
     (require 'cl-lib)
   #+end_src

** Org mode
   #+begin_src emacs-lisp
     (require 'org)
     (require 'org-tempo)
   #+end_src

** Paren face
  #+begin_src emacs-lisp
    (require 'paren-face)
  #+end_src

** Always ensure packages are installed
   #+begin_src emacs-lisp
     (setq straight-use-package-by-default t)
   #+end_src

* Macros
** Lisp indent function
    #+begin_src emacs-lisp
      (setq lisp-indent-function 'common-lisp-indent-function)
    #+end_src

** Define indent function
   #+begin_src emacs-lisp
     (defun my/lisp-indent-function-arglist (indent-point state)
       (if (eq lisp-indent-function 'common-lisp-indent-function)
           `(_ ,state ,indent-point _ _)
           `(,indent-point ,state)))

     (defmacro defindent (name arglist &rest body)
       "Define an indent function.

     Automatically decides to use different argument lists, depending on which
     indent function is used. ARGLIST is a list of two elements:
     (INDENT-POINT-VAR STATE). INDENT-POINT-VAR is the name of the variable that
     holds the point at which the indentation function is called, and STATE-VAR
     is the name of the variable which holds the `parse-partial-sexp' state at
     that position."
       (declare (indent defun))
       `(defun ,name ,(my/lisp-indent-function-arglist (car arglist) (cadr arglist))
          ,@body))
   #+end_src

** Multiple call macro
   #+begin_src emacs-lisp
     (defmacro my/multiple-call (form-name &rest params)
       (declare (indent 1))
       `(progn ,@ (mapcar #'(lambda (params) (cons form-name params) params))))
   #+end_src

** Hook combination macro
   #+begin_src emacs-lisp
     (defun mklist (x) (if (listp x) x (list x)))

     (defun hook->add-hook-form (hook rest)
       `(add-hook ',hook (lambda () ,@rest)))

     (defun pair->add-hook-forms (pair)
       (let* ((first (mklist (car pair)))
              (rest (cdr pair)))
         (mapcar (lambda (x) (hook->add-hook-form x rest)) first)))

     (defindent my/add-hooks-indent-function (indent-point state)
       (let ((depth (elt state 0))
             (inside-a-string-p (elt state 3)))
         (cond
           (inside-a-string-p 0)
           ((< depth 2) (list 2))
           ((< depth 3) (list 5))
           (t nil))))

     (defmacro my/add-hooks (&rest pairs)
       "Add hooks to the specified modes.
     TODO: write documentation"
       (declare (indent my/add-hooks-indent-function))
       `(progn ,@(mapcan #'pair->add-hook-forms pairs)))
   #+end_src

** Global set keys macro
   #+begin_src emacs-lisp
     (defindent my/global-set-keys-indent-function (indent-point state)
       (if (< (elt state 0) 2)
           (list 2)
           nil))

     (defun my/pair->global-set-key-form (pair)
       `(global-set-key (kbd ,(car pair)) ,(cadr pair)))

     (defmacro my/global-set-keys (&rest pairs)
       (declare (indent my/global-set-keys-indent-function))
       `(progn
          ,@ (mapcar #'my/pair->global-set-key-form pairs)))
   #+end_src

* Vars
** Indent offset
   #+begin_src emacs-lisp
     (defvar my/indent-offset 2)
   #+end_src

** Font
   #+begin_src emacs-lisp
     (defvar main-font "Fantasque Sans Mono 12")
   #+end_src

* Themes
** Theme load path
   #+begin_src emacs-lisp
     (add-to-list 'custom-theme-load-path "~/.emacs.d/themes/")
   #+end_src

** Theme loading function
   #+begin_src emacs-lisp
     (defvar my/after-theme-load-hook '()
       "List of functions to run after a theme has been loaded.")
     (defun my/load-theme (theme &optional no-confirm no-enable)
       "Load `theme' using LOAD-THEME, afterwards running the MY-AFTER-THEME-LOAD-HOOK"
       (interactive
        (list (intern
               (completing-read "Load custom theme: " (mapcar #'symbol-name (custom-available-themes))))
              nil
              nil))
       (load-theme theme no-confirm no-enable)
       (run-hook-with-args 'my/after-theme-load-hook))
   #+end_src

** Current theme
  #+begin_src emacs-lisp
    (use-package gruvbox-theme
      :straight t
      :custom
      (tao-theme-use-boxes . nil)
      (tao-theme-use-sepia . nil))

    (defvar my/theme 'gruvbox-dark-medium)
  #+end_src

** Default font
   #+begin_src emacs-lisp
     (add-to-list 'default-frame-alist
                  `(font . ,main-font))

     (set-face-attribute 'default nil :font main-font)
     (set-face-attribute 'font-lock-comment-face nil :font main-font)
   #+end_src

** Faces
   #+begin_src emacs-lisp
     (defun my/custom-face-config ()
       (let ((default-bg (face-attribute 'default :background))
             (mode-line-inactive-bg (face-attribute 'mode-line-inactive :background))
             (mode-line-bg (face-attribute 'mode-line :background))
             (highlight-bg (face-attribute 'isearch :background)))
         (set-face-attribute 'show-paren-match nil :background highlight-bg)
         (set-face-attribute 'mode-line nil :background default-bg)
         (set-face-attribute 'mode-line-inactive nil :background default-bg)
         (set-face-attribute 'line-number nil :background default-bg)
         (set-face-attribute 'selectrum-current-candidate nil
                             :background default-bg
                             :underline t)
         (set-face-attribute 'font-lock-comment-face nil :slant 'normal)
         (set-face-attribute 'font-lock-builtin-face nil :slant 'normal)
         (set-face-attribute 'font-lock-doc-face nil :slant 'normal)

         ;; gruvbox specific
         ;; (set-face-attribute 'default nil :foreground "#ebdbb2")
         ))

     (add-hook 'my/after-theme-load-hook 'my/custom-face-config)
   #+end_src

** Theme setting function
   #+begin_src emacs-lisp
     (defun my/frame-behaviors (&optional frame)
       "Make frame- and/or terminal-local changes."
       (set-face-attribute 'fixed-pitch nil :font main-font)
       (set-face-attribute 'variable-pitch nil :font main-font))

     (add-hook 'after-make-frame-functions 'my/frame-behaviors)
     (add-hook 'after-init-hook (lambda () (my/load-theme my/theme t)))
   #+end_src

** Mode Line
   #+begin_src emacs-lisp
     (defvar my/right-side-mode-line-format "line %l, col %C")

     (defun my/length-mode-line (mode-line)
       (length (format-mode-line mode-line)))

     (defun simple-mode-line-render (left right)
       "Return a string of `window-width' length.
     Containing LEFT, and RIGHT aligned respectively."
       (let* ((window-width (window-total-width))
              (mode-line-lengths (apply #'+ (mapcar #'my/length-mode-line (list left right))))
              (available-width (- window-width mode-line-lengths))
              (format-string (format "%%%ds" available-width)))
         (append left (list (format format-string "")) right)))

     (simple-mode-line-render '("test") '("another"))

     (defun my/buffer-modified-flag ()
       (when (buffer-modified-p)
         "[+]"))

     (defun my/buffer-readonly-flag ()
       (when buffer-read-only
         "[RO]"))

     (setq-default
      mode-line-format
      '((:eval
         (simple-mode-line-render
          ;; Left
          '(" %m Â» %b "
            (:eval (my/buffer-modified-flag))
            (:eval (my/buffer-readonly-flag)))
          ;; Right
          '("line %l, col %C")))))
   #+end_src

* Packages
** Lsp-mode
   #+begin_src emacs-lisp
     (use-package lsp-mode
       :straight t
       :commands lsp
       :custom
       (lsp-ui-sideline-enable nil)
       (lsp-rust-analyzer-cargo-watch-command "clippy")
       (lsp-eldoc-render-all nil)
       (lsp-idle-delay 0.3)
       (lsp-rust-analyzer-server-display-inlay-hints t)
       :config
       (add-hook 'lsp-mode-hook 'lsp-ui-mode))

     (use-package lsp-ui
       :straight t
       :commands lsp-ui-mode
       :custom
       (lsp-ui-peek-always-show t)
       (lsp-ui-sideline-show-hover t)
       (lsp-ui-doc-enable nil))
   #+end_src

** Rust
*** Rustic
   #+begin_src emacs-lisp
     (use-package rustic
       :straight t
       :bind (:map rustic-mode-map
                   ("M-j" . lsp-ui-imenu)
                   ("M-?" . lsp-find-references)
                   ("C-c C-c l" . flycheck-list-errors)
                   ("C-c C-c a" . lsp-execute-code-action)
                   ("C-c C-c r" . lsp-rename)
                   ("C-c C-c q" . lsp-workspace-restart)
                   ("C-c C-c Q" . lsp-workspace-shutdown)
                   ("C-c C-c s" . lsp-rust-analyzer-status))
       :config
       (setq rustic-format-on-save t))
   #+end_src

** Lua mode
   #+begin_src emacs-lisp
     (use-package lua-mode
       :straight t)
   #+end_src

** Flycheck
   #+begin_src emacs-lisp
     (use-package flycheck
       :straight t)
   #+end_src

** Parentheses
*** Paredit
   #+begin_src emacs-lisp
     (use-package paredit
       :straight t)
   #+end_src

*** Highlight-parentheses
   #+begin_src emacs-lisp
     (use-package highlight-parentheses
       :straight t
       :custom
       (highlight-parentheses-delay 0))
   #+end_src

** Company
   #+begin_src emacs-lisp
     (use-package company
       :straight t
       :custom
       (company-idle-delay 0.2)
       :bind
       (:map company-active-map
             ("M-n" . company-select-next)
             ("M-p" . company-select-previous)
             ("M-<" . company-select-first)
             ("M->" . company-select-last)))
   #+end_src

** Yasnippet
   #+begin_src emacs-lisp
     (use-package yasnippet
       :straight t
       :custom
       (yas-snippet-dirs '("~/.emacs.d/snippets"))
       :config
       (yas-reload-all))
   #+end_src

** Dashboard
   #+begin_src emacs-lisp
     (defun my/choose-initial-buffer ()
       (unless (get-buffer-window "*dashboard*" 0)
         (get-buffer "*dashboard*")))

     (use-package dashboard
         :straight t
         :custom
         (initial-buffer-choice #'my/choose-initial-buffer)
         (dashboard-banner-logo-title "O U R macs")
         (dashboard-center-content t)
         (dashboard-items '((recents  . 4)
                            (bookmarks . 4)
                            (agenda . 3)))
         (dashboard-page-separator "\n")
         (dashboard-startup-banner (expand-file-name "~/.emacs.d/emacs-splash.png"))
         :config
         (dashboard-setup-startup-hook))
   #+end_src

** Initial scratch message
   #+begin_src emacs-lisp
     (setq initial-scratch-message
           ";; USAGE GUIDE
     ;; 1) Open files with File->Visit File
     ;; 2) Standard editor movement keys up down left right, etc. advanced commands
     ;;    in the menu bar
     ;; 3) Control + Y to paste and Alt + W to copy. Select an area and use Control +
     ;;    W to cut it.

     ")
   #+end_src

** Avy
   #+begin_src emacs-lisp
     (use-package avy
       :straight t
       :bind (("C-;" . avy-goto-word-1)))
   #+end_src

** Sly
   #+begin_src emacs-lisp
     (defun set-sly-mrepl-faces ()
       (let ((string-fg (face-attribute 'font-lock-string-face :foreground))
             (comment-fg (face-attribute 'font-lock-comment-face :foreground)))
         (set-face-attribute 'sly-mrepl-note-face nil :foreground comment-fg)
         (set-face-attribute 'sly-mrepl-output-face nil :foreground string-fg)))

     (use-package sly
       :straight t
       :config
       (setq inferior-lisp-program "ccl")
       (add-hook 'sly-mrepl-mode-hook #'set-sly-mrepl-faces))
   #+end_src

** Editor configuration (=editorconfig=)
   #+begin_src emacs-lisp
     (use-package editorconfig
       :straight t
       :config
       (editorconfig-mode 1))
   #+end_src

** Web Mode
   #+begin_src emacs-lisp
     (use-package web-mode
         :straight t
         :config
         (setq web-mode-markup-indent-offset my/indent-offset))
   #+end_src

** Scss mode
   #+begin_src emacs-lisp
     (use-package scss-mode
         :straight t
         :custom ((scss-compile-at-save t)))
   #+end_src

* Key mappings
  #+begin_src emacs-lisp
    (defvar my/avy-colon-command 'avy-goto-word-1)

    (defalias 'yes-or-no-p 'y-or-n-p)

    (defun my/tab-insert-command ()
      (interactive)
      (insert "	"))

    (defun my/nop () (interactive) nil)

    (my/global-set-keys
      ("C-x b" 'ibuffer)
      ("C-x C-b" 'ido-switch-buffer)
      ("C-x k" 'kill-current-buffer)
      ("C-c q" 'delete-window)
      ("C-c a" 'org-agenda)
      ("C-;" my/avy-colon-command)
      ("C-<tab>" 'my/tab-insert-command)
      ("M-ESC" 'my/nop))
  #+end_src

** Config visit/reload
  #+begin_src emacs-lisp
    (defun config-visit ()
      "Find config.org"
      (interactive)
      (find-file "~/.emacs.d/config.org"))

    (defun config-reload ()
      "Reload the configuration file"
      (interactive)
      (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))
    (global-set-key (kbd "C-c r") 'config-reload)
    (global-set-key (kbd "C-c e") 'config-visit)
  #+end_src

* Org mode
** Org contrib
   #+begin_src emacs-lisp
     (use-package org-contrib
         :straight (org-contrib :repo "https://git.sr.ht/~bzg/org-contrib"))
   #+end_src

** Emacs lisp code blocks with <el TAB
   #+begin_src emacs-lisp
     (add-to-list 'org-modules 'org-tempo)
     (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
   #+end_src

** For latex export
   #+begin_src emacs-lisp
     (add-to-list 'org-latex-packages-alist '("AUTO" "babel" t ("pdflatex")))
     (add-to-list 'org-latex-packages-alist '("" "minted" t ("pdflatex")))

     (setq
      org-latex-title-command nil
      org-latex-listings 'minted
      org-latex-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f")
      org-latex-minted-options '(("breaklines" "true") ("breakanywhere" "true"))
      )
   #+end_src

** Adapt indentation to outline node level
   #+begin_src emacs-lisp
     (setq org-adapt-indentation t)
   #+end_src

** Agenda
   #+begin_src emacs-lisp
     (setq org-agenda-files (file-expand-wildcards "~/.emacs.d/org/agenda/*.org"))
   #+end_src

** Org bullets
   #+begin_src emacs-lisp
     (use-package org-bullets
       :straight t
       :config
       ;; Default: '("â" "â" "â¸" "â¿")
       ;; Second:  '("*" "â" "â" "Â·")
       ;; Third:   '("â" "*" "â¢" "Â·")
       ;; â¥ â â â â â¯ â â  â£ â¦ â¢ â â â â¶
       ;; âº  â â¸
       (setq org-bullets-bullet-list '("â" "*" "â¢" "Â·"))
       (add-hook 'org-mode-hook
                 #'org-bullets-mode))
   #+end_src

** Auto save buffers
   #+begin_src emacs-lisp
     (advice-add 'org-agenda-quit :before 'org-save-all-org-buffers)
   #+end_src

** Org capture disable the dumb bookmark
   #+begin_src emacs-lisp
     (setq org-capture-bookmark nil)
   #+end_src

** Org src should appear in the same window instead of splitting
    #+begin_src emacs-lisp
      (setq org-src-window-setup 'current-window)
    #+end_src

** Org roam
   #+begin_src emacs-lisp
     (use-package org-roam
       :straight t
       :init
       (setq org-roam-v2-ack t)
       :custom
       (org-roam-directory (file-truename "~/.emacs.d/org/roam/"))
       (org-roam-complete-everywhere t)
       :bind (("C-c n l" . org-roam-buffer-toggle)
              ("C-c n f" . org-roam-node-find)
              ("C-c n i" . org-roam-node-insert)
              ("C-c n g" . org-roam-graph)
              ("C-c n c" . org-roam-capture)
              ;; Dailies
              ("C-c n j" . org-roam-dailies-capture-today)
              :map org-mode-map
              ("C-M-i"   . completion-at-point))
       :config
       (org-roam-setup)
       ;; If using org-roam-protocol
       ;(require 'org-roam-protocol)
       )
   #+end_src

* Preferences
** Auto hide compilation buffer
   #+begin_src emacs-lisp
     (defun my/auto-hide-compilation-window (buf str)
       (when (null (string-match ".*exited abnormally.*" str))
         (let ((win (get-buffer-window buf 'visible)))
           (when win (delete-window win)))))

     (add-hook 'compilation-finish-functions 'my/auto-hide-compilation-window)
   #+end_src

** Select the help window when opening it
   #+begin_src emacs-lisp
     (setq help-window-select t)
   #+end_src

** Backup files and auto saving
    #+begin_src emacs-lisp
      (setq make-backup-files nil
            auto-save-default nil)
    #+end_src

** Hide startup screen
    #+begin_src emacs-lisp
      (setq inhibit-startup-screen t)
    #+end_src

** Show matching parentheses
    #+begin_src emacs-lisp
      (setq show-paren-delay 0)
      (show-paren-mode 1)
    #+end_src

** Add newline at the end of file
    #+begin_src emacs-lisp
      (setq require-final-newline t)
    #+end_src

** Display column numbers
    #+begin_src emacs-lisp
      (setq column-number-mode t)
    #+end_src

** Window splitting config
   Redefined =split-window-sensibly= to prefer splitting windows vertically
    #+begin_src emacs-lisp
      (defun split-window-sensibly (&optional window)
        "Modified by >>ME<< to prefer splitting windows vertically

      Split WINDOW in a way suitable for `display-buffer'.
      WINDOW defaults to the currently selected window.
      If `split-width-threshold' specifies an integer, WINDOW is at
      least `split-width-threshold' columns wide and can be split
      horizontally, split WINDOW into two windows side by side and
      return the lower window.  Otherwise, if `split-height-threshold'
      specifies an integer, WINDOW is at least `split-height-threshold'
      lines tall and can be split vertically, split WINDOW into two
      windows side by side and return the window on the right.  If this
      can't be done either and WINDOW is the only window on its frame,
      try to split WINDOW vertically disregarding any value specified
      by `split-height-threshold'.  If that succeeds, return the lower
      window.  Return nil otherwise.

      By default `display-buffer' routines call this function to split
      the largest or least recently used window.  To change the default
      customize the option `split-window-preferred-function'.

      You can enforce this function to not split WINDOW horizontally,
      by setting (or binding) the variable `split-width-threshold' to
      nil.  If, in addition, you set `split-height-threshold' to zero,
      chances increase that this function does split WINDOW vertically.

      In order to not split WINDOW vertically, set (or bind) the
      variable `split-height-threshold' to nil.  Additionally, you can
      set `split-width-threshold' to zero to make a horizontal split
      more likely to occur.

      Have a look at the function `window-splittable-p' if you want to
      know how `split-window-sensibly' determines whether WINDOW can be
      split."
        (let ((window (or window (selected-window))))
          (or (and (window-splittable-p window t)
                   (with-selected-window window
                     (split-window-right)))
              (and (window-splittable-p window)
                   (with-selected-window window
                     (split-window-below)))
              (and
               ;; If WINDOW is the only usable window on its frame (it is
               ;; the only one or, not being the only one, all the other
               ;; ones are dedicated) and is not the minibuffer window, try
               ;; to split it vertically disregarding the value of
               ;; `split-height-threshold'.
               (let ((frame (window-frame window)))
                 (or
                  (eq window (frame-root-window frame))
                  (catch 'done
                    (walk-window-tree (lambda (w)
                                        (unless (or (eq w window)
                                                    (window-dedicated-p w))
                                          (throw 'done nil)))
                                      frame nil 'nomini)
                    t)))
               (not (window-minibuffer-p window))
               (let ((split-height-threshold 0))
                 (when (window-splittable-p window)
                   (with-selected-window window
                     (split-window-below))))))))

      (setq split-width-threshold 120)
    #+end_src

** Don't confirm killing processes
    #+begin_src emacs-lisp
      (setq confirm-kill-process nil)
    #+end_src

** Scroll conservatively (line by line)
    #+begin_src emacs-lisp
      (setq scroll-conservatively 10)
    #+end_src

** Disable tab indentation
    #+begin_src emacs-lisp
      (setq-default indent-tabs-mode nil)
    #+end_src

** Tab width
    #+begin_src emacs-lisp
      (setq-default tab-width 4)
    #+end_src

** Don't wrap lines
    #+begin_src emacs-lisp
      (setq-default truncate-lines t)
    #+end_src

** Fill column
    #+begin_src emacs-lisp
      (setq-default fill-column 80)
    #+end_src

** C language indentation
    #+begin_src emacs-lisp
      (setq-default c-default-style '((c-mode . "bsd"))
                    c-basic-offset tab-width
                    cperl-indent-level tab-width)
    #+end_src

** Reserve space for line numbers
    #+begin_src emacs-lisp
    (setq-default display-line-numbers-width 3)
    #+end_src

** Open =.cl= files as lisp files
  #+begin_src emacs-lisp
    (add-to-list 'auto-mode-alist '("\\.cl\\'" . lisp-mode))
  #+end_src

** Fringes
   #+begin_src emacs-lisp
     (fringe-mode '(2 . 0))
   #+end_src

** Selectrum
*** Install
   #+begin_src emacs-lisp
     (use-package selectrum
       :straight t
       :config
       (selectrum-mode +1))
   #+end_src

*** Prescient
    #+begin_src emacs-lisp
      (use-package selectrum-prescient
        :straight t
        :config
        ;; to make sorting and filtering more intelligent
        (selectrum-prescient-mode +1)

        ;; to save your command history on disk, so the sorting gets more
        ;; intelligent over time
        (prescient-persist-mode +1))
    #+end_src

*** Marginalia (information in completion annotations)
    #+begin_src emacs-lisp
      (defun set-marginalia-faces ()
        (set-face-attribute 'marginalia-documentation nil :slant 'normal))

      (use-package marginalia
        :straight t
        :bind (("M-A" . marginalia-cycle)
               :map minibuffer-local-map
               ("M-A" . marginalia-cycle))
        :init
        ;; Must be in the :init section of use-package such that the mode gets
        ;; enabled right away. Note that this forces loading the package.
        (marginalia-mode)
        :config
        (add-hook 'my/after-theme-load-hook #'set-marginalia-faces))
    #+end_src

*** Ido file behavior
    #+begin_src emacs-lisp
      (defun selectrum-fido-backward-updir ()
        "Delete char before or go up directory, like `ido-mode'."
        (interactive)
        (if (and (eq (char-before) ?/)
                 (eq (selectrum--get-meta 'category) 'file))
            (save-excursion
              (goto-char (1- (point)))
              (when (search-backward "/" (point-min) t)
                (delete-region (1+ (point)) (point-max))))
          (call-interactively 'backward-delete-char)))

      (defun selectrum-fido-delete-char ()
        "Delete char or maybe call `dired', like `ido-mode'."
        (interactive)
        (let ((end (point-max)))
          (if (or (< (point) end) (not (eq (selectrum--get-meta 'category) 'file)))
              (call-interactively 'delete-char)
            (dired (file-name-directory (minibuffer-contents)))
            (exit-minibuffer))))

      (defun selectrum-fido-ret ()
        "Exit minibuffer or enter directory, like `ido-mode'."
        (interactive)
        (let* ((dir (and (eq (selectrum--get-meta 'category) 'file)
                         (file-name-directory (minibuffer-contents))))
               (current (selectrum-get-current-candidate))
               (probe (and dir current
                           (expand-file-name (directory-file-name current) dir))))
          (cond ((and probe (file-directory-p probe) (not (string= current "./")))
                 (selectrum-insert-current-candidate))
                (t
                 (selectrum-select-current-candidate)))))


      (define-key selectrum-minibuffer-map (kbd "RET") 'selectrum-fido-ret)
      (define-key selectrum-minibuffer-map (kbd "DEL") 'selectrum-fido-backward-updir)
      (define-key selectrum-minibuffer-map (kbd "C-d") 'selectrum-fido-delete-char)
    #+end_src

** Ibuffer
*** Expert mode (no confirmations)
    #+begin_src emacs-lisp
      (setq ibuffer-expert t)
    #+end_src

*** Filter groups
   #+begin_src emacs-lisp
     (setq ibuffer-saved-filter-groups
           '(("default"
              ("lisp" (or
                       (mode . lisp-mode)
                       (mode . scheme-mode)
                       (mode . emacs-lisp-mode)))
              ("org" (or (mode . org-mode)
                         (name . "\\*Org Src.*\\*")))
              ("emacs" (or
                        (name . "^\\*scratch\\*$")
                        (name . "^\\*Messages\\*$")))
              ("trashcan" (or
                           (name . "^\\*straight-process\\*$")
                           (name . "^\\*Compile-Log\\*$")
                           (name . "^\\*inferior-lisp\\*$")
                           (name . "^\\*slime-events\\*$"))))))
   #+end_src

** Disable the scroll bar, menu bar and the tool bar
   #+begin_src emacs-lisp
     (scroll-bar-mode -1)
     (menu-bar-mode -1)
     (tool-bar-mode -1)
   #+end_src

** Cursor
   Blinking box.
   #+begin_src emacs-lisp
     (blink-cursor-mode)
     (setq-default cursor-type t)
   #+end_src

** Beacon mode
   Highlights the cursor when the window scrolls
   #+begin_src emacs-lisp
     (use-package beacon
       :straight t
       :config
       (beacon-mode 1)
       (setq beacon-blink-when-focused t)
       (setq beacon-blink-when-point-moves-vertically 10)
       (setq beacon-blink-duration 0.4)
       (setq beacon-blink-delay 0.3)
       (setq beacon-size 20)
       (push 'ibuffer-mode beacon-dont-blink-major-modes))
   #+end_src

** Whitespace
   #+begin_src emacs-lisp
     (setq whitespace-style '(face tabs tab-mark)
           whitespace-display-mappings '((tab-mark 9 [8250 9] [92 9])
                                         (space-mark 32 [183] [46])))
   #+end_src

** Have custom in a separate file (=.emacs.d/custom.el=)
   #+begin_src emacs-lisp
     (setq custom-file "~/.emacs.d/custom.el")
     (load "~/.emacs.d/custom.el")
   #+end_src

** Completion buffer popping up
   #+begin_src emacs-lisp
     (setq completion-auto-help 'lazy)
   #+end_src

** Html auto tag closing
   #+begin_src emacs-lisp
     (setq sgml-quick-keys 'close)
   #+end_src

* Hooks
  #+begin_src emacs-lisp
    (my/add-hooks
      ((lisp-mode-hook scheme-mode-hook emacs-lisp-mode-hook)
         (setq tab-width my/indent-offset indent-tabs-mode nil fill-column 100)
         (paredit-mode 1)
         (paren-face-mode))
      (prog-mode-hook
         (company-mode)
         (yas-minor-mode))
      (c-mode-hook
         (font-lock-mode -1))
      (before-save-hook
         (delete-trailing-whitespace))
      (org-mode-hook
         (auto-fill-mode))
      ((text-mode-hook org-mode-hook prog-mode-hook)
         (display-fill-column-indicator-mode)
         (whitespace-mode))
      (rustic-mode-hook
         (setq-local buffer-save-without-query t))
      (ibuffer-mode-hook
         (ibuffer-switch-to-saved-filter-groups "default"))
      (sly-mode-hook
         (company-mode)
         (paren-face-mode))
      (sly-mrepl-mode-hook
         (delete-other-windows)
         (visual-line-mode))
      ((help-mode-hook sly-db-mode-hook)
         (visual-line-mode))
      (whitespace-mode-hook
         (set-face-attribute 'whitespace-tab nil :background (face-attribute 'default :background)))
      (css-mode-hook
         (electric-pair-local-mode)))
   #+end_src
