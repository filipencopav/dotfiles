#+STARTUP: CONTENT

* Requires
** Load path
   #+begin_src emacs-lisp
     (eval-when-compile
       (add-to-list 'load-path (expand-file-name "~/.emacs.d/elisp/")))
   #+end_src

** Common Lisp library
   #+begin_src emacs-lisp
     (require 'cl-lib)
   #+end_src

** Org mode
   #+begin_src emacs-lisp
     (eval-when-compile
       (require 'org-element)
       (require 'org-tempo)
       (require 'org)
       (require 'ox-latex))
   #+end_src

** Paren face
  #+begin_src emacs-lisp
    (require 'paren-face)
  #+end_src

* Macros
** Lisp indent function
    #+begin_src emacs-lisp
      (setq lisp-indent-function 'common-lisp-indent-function)
    #+end_src

** Define indent function
   #+begin_src emacs-lisp
     (defun my/lisp-indent-function-arglist (indent-point state)
       (if (eq lisp-indent-function 'common-lisp-indent-function)
           `(_ ,state ,indent-point _ _)
           `(,indent-point ,state)))

     (defmacro defindent (name arglist &rest body)
       "Define an indent function.

     Automatically decides to use different argument lists, depending on which
     indent function is used. ARGLIST is a list of two elements:
     (INDENT-POINT-VAR STATE). INDENT-POINT-VAR is the name of the variable that
     holds the point at which the indentation function is called, and STATE-VAR
     is the name of the variable which holds the `parse-partial-sexp' state at
     that position."
       (declare (indent defun))
       `(defun ,name ,(my/lisp-indent-function-arglist (car arglist) (cadr arglist))
          ,@body))
   #+end_src

** Multiple call macro
   #+begin_src emacs-lisp
     (defmacro my/multiple-call (form-name &rest params)
       (declare (indent 1))
       `(progn ,@ (mapcar #'(lambda (params) (cons form-name params) params))))
   #+end_src

** Hook combination macro
   #+begin_src emacs-lisp
     (defun mklist (x) (if (listp x) x (list x)))

     (defun hook->add-hook-form (hook rest)
       `(add-hook ',hook (lambda () ,@rest)))

     (defun pair->add-hook-forms (pair)
       (let* ((first (mklist (car pair)))
              (rest (cdr pair)))
         (mapcar (lambda (x) (hook->add-hook-form x rest)) first)))

     (defindent my/add-hooks-indent-function (indent-point state)
       (let ((depth (elt state 0))
             (inside-a-string-p (elt state 3)))
         (cond
           (inside-a-string-p 0)
           ((< depth 2) (list 2))
           ((< depth 3) (list 5))
           (t nil))))

     (defmacro my/add-hooks (&rest pairs)
       "Add hooks to the specified modes.
     TODO: write documentation"
       (declare (indent my/add-hooks-indent-function))
       `(progn ,@(mapcan #'pair->add-hook-forms pairs)))
   #+end_src

** Global set keys macro
   #+begin_src emacs-lisp
     (defindent my/global-set-keys-indent-function (indent-point state)
       (if (< (elt state 0) 2)
           (list 2)
           nil))

     (defun my/pair->global-set-key-form (pair)
       `(global-set-key (kbd ,(car pair)) ,(cadr pair)))

     (defmacro my/global-set-keys (&rest pairs)
       (declare (indent my/global-set-keys-indent-function))
       `(progn
          ,@ (mapcar #'my/pair->global-set-key-form pairs)))
   #+end_src

* Vars
** Indent offset
   #+begin_src emacs-lisp
     (defvar my/indent-offset 2)
   #+end_src

** Font
   #+begin_src emacs-lisp
     (defvar main-font nil "Font used everywhere")
     (setq main-font "Fantasque Sans Mono:pixelsize=14")
     (add-to-list 'default-frame-alist
                  `(font . ,main-font))
   #+end_src

* Themes
** Theme load path
   #+begin_src emacs-lisp
     (add-to-list 'custom-theme-load-path "~/.emacs.d/themes/")
   #+end_src

** Theme loading function
   #+begin_src emacs-lisp
     (defvar my/after-theme-load-hook '()
       "List of functions to run after a theme has been loaded.")
     (defun my/load-theme (theme &optional no-confirm no-enable)
       "Load `theme' using LOAD-THEME, afterwards running the MY-AFTER-THEME-LOAD-HOOK"
       (interactive
        (list (intern
               (completing-read "Load custom theme: " (mapcar #'symbol-name (custom-available-themes))))
              nil
              nil))
       (load-theme theme no-confirm no-enable)
       (run-hook-with-args 'my/after-theme-load-hook theme))
   #+end_src

** Current theme
  #+begin_src emacs-lisp
    (defvar my/theme nil)

    (leaf gruvbox-theme
      :config
      (add-hook 'my/after-theme-load-hook
                (lambda (theme)
                  (when (cl-find theme '(gruvbox-dark-light gruvbox-dark-medium gruvbox-dark-hard))
                    (set-face-attribute 'default nil :foreground "#ebdbb2")))))

    (setq my/theme 'gruvbox-dark-medium)
  #+end_src

** Theme setting function
   #+begin_src emacs-lisp
     (defun my/frame-behaviors (&optional frame)
       "Make frame- and/or terminal-local changes."
       (set-face-attribute 'default nil :font main-font)
       (set-face-attribute 'font-lock-comment-face nil :font main-font)
       (set-face-attribute 'fixed-pitch nil :font main-font)
       (set-face-attribute 'variable-pitch nil :font main-font))

     (add-hook 'server-after-make-frame-hook 'my/frame-behaviors)
     (add-hook 'after-init-hook (lambda () (my/load-theme my/theme t)))
   #+end_src

** Faces
   #+begin_src emacs-lisp
     (defun my/custom-face-config (&optional theme)
       (let ((default-bg (face-attribute 'default :background))
             (mode-line-inactive-bg (face-attribute 'mode-line-inactive :background)))
         (when (cl-find theme '(gruvbox-dark-medium gruvbox-dark-hard gruvbox-dark-soft))
           (set-face-attribute 'mode-line nil :background default-bg)
           (set-face-attribute 'mode-line-inactive nil :background default-bg)
           (set-face-attribute 'line-number nil :background default-bg))))

     (add-hook 'my/after-theme-load-hook 'my/custom-face-config)
   #+end_src

** Mode Line
   #+begin_src emacs-lisp
     (defun my/length-mode-line (mode-line)
       (length (format-mode-line mode-line)))

     (defun simple-mode-line-render (left right)
       "Return a string of `window-width' length.
     Containing LEFT, and RIGHT aligned respectively."
       (let* ((window-width (window-total-width))
              (mode-line-lengths (apply #'+ (mapcar #'my/length-mode-line (list left right))))
              (available-width (- window-width mode-line-lengths))
              (format-string (format "%%%ds" available-width)))
         (append left (list (format format-string "")) right)))

     (defun my/buffer-modified-flag ()
       (when (buffer-modified-p)
         (if buffer-read-only
             ""
           "[+]")))

     (defun my/buffer-readonly-flag ()
       (when buffer-read-only
         "[RO]"))

     (setq-default
      mode-line-format
      '((:eval
         (simple-mode-line-render
          ;; Left
          '(" %m » %b "
            (:eval (my/buffer-modified-flag))
            (:eval (my/buffer-readonly-flag)))
          ;; Right
          '("line %l, col %2C")))))
   #+end_src

* Packages
** Eglot (LSP; Language Server Protocol)
   #+begin_src emacs-lisp
     (leaf eglot
       :config
       (add-hook 'eglot--managed-mode-hook (lambda () (flymake-mode -1)))
       (setcdr (assq 'java-mode eglot-server-programs) '("/usr/share/java/java-language-server/lang_server_linux.sh"))
       (add-to-list 'eglot-server-programs '(c-mode "ccls")))
   #+end_src

** Flycheck
   #+begin_src emacs-lisp
     (leaf flycheck)
   #+end_src

** Rust
*** Rustic
   #+begin_src emacs-lisp
     (leaf rustic
       :after (flycheck eglot)
       :bind (:rustic-mode-map
              ("M-j" . eglot-imenu)
              ("M-?" . xref-find-references)
              ("C-c C-c l" . flycheck-list-errors)
              ("C-c C-c r" . eglot-rename)
              ("C-c C-c q" . eglot-reconnect)
              ("C-c C-c Q" . eglot-shutdown)
              ("C-c C-c o" . eglot-code-action-organize-imports)
              ("C-c C-c b" . rustic-cargo-build)
              ("C-c C-c c" . rustic-cargo-check))
       :init
       (setq rustic-lsp-server 'rls)
       :hook (rustic-mode-hook . (lambda () (setq-local buffer-save-without-query t)))
       :config
       (setq rustic-lsp-client 'eglot)
       (setq rustic-format-on-save t))
   #+end_src

** Lua mode
   #+begin_src emacs-lisp
     (leaf lua-mode)
   #+end_src

** Parentheses
*** Paredit
   #+begin_src emacs-lisp
     (leaf paredit
       :hook ((lisp-mode-hook scheme-mode-hook emacs-lisp-mode-hook) . paredit-mode))
   #+end_src

*** Highlight-parentheses
   #+begin_src emacs-lisp
     (leaf highlight-parentheses
       :custom
       (highlight-parentheses-delay . 0))
   #+end_src

** Yasnippet
   #+begin_src emacs-lisp
     (leaf yasnippet
       :custom
       (yas-snippet-dirs . '("~/.emacs.d/snippets"))
       :hook (prog-mode-hook . yas-minor-mode)
       :config
       (yas-reload-all))
   #+end_src

** Dashboard
   #+begin_src emacs-lisp
     (defun my/choose-initial-buffer ()
       (unless (get-buffer-window "*dashboard*" 0)
         (get-buffer "*dashboard*")))

     (leaf dashboard
       :setq
       (initial-buffer-choice       . 'my/choose-initial-buffer)
       (dashboard-banner-logo-title . "O U R macs")
       (dashboard-center-content    . t)
       (dashboard-page-separator    . "\n")
       (dashboard-items . '((bookmarks . 4)
                            (agenda . 4)))
       :config
       (setq dashboard-startup-banner (expand-file-name "~/.emacs.d/emacs-splash.png"))
       (dashboard-setup-startup-hook))
   #+end_src

** Initial scratch message
   #+begin_src emacs-lisp
     (setq initial-scratch-message
           ";; USAGE GUIDE
     ;; 1) Open files with File->Visit File
     ;; 2) Standard editor movement keys up down left right, etc. advanced commands
     ;;    in the menu bar
     ;; 3) Control + Y to paste and Alt + W to copy. Select an area and use
     ;;    Control + W to cut it.

     ")
   #+end_src

** Avy
   #+begin_src emacs-lisp
     (leaf avy
       :bind (("C-;" . avy-goto-char-2)))
   #+end_src

** Sly
   #+begin_src emacs-lisp
     (defun set-sly-mrepl-faces ()
       (let ((string-fg (face-attribute 'font-lock-string-face :foreground))
             (comment-fg (face-attribute 'font-lock-comment-face :foreground)))
         (set-face-attribute 'sly-mrepl-note-face nil :foreground comment-fg)
         (set-face-attribute 'sly-mrepl-output-face nil :foreground string-fg)))

     (leaf sly
       :custom
       (inferior-lisp-program . "sbcl")
       (sly-lisp-implementations . `((sbcl ("sbcl"
                                            "--core"
                                            ,(expand-file-name "~/.emacs.d/slynk/sbcl.core-for-sly")))))
       :config (add-hook 'sly-mrepl-mode-hook #'set-sly-mrepl-faces))
   #+end_src

** Editor configuration (=editorconfig=)
   #+begin_src emacs-lisp
     (leaf editorconfig
       :config
       (editorconfig-mode 1))
   #+end_src

** Scss mode
   #+begin_src emacs-lisp
     (leaf scss-mode
         :init (setq scss-compile-at-save t))
   #+end_src

** C# mode
   #+begin_src emacs-lisp
     (leaf csharp-mode
       :after eglot
       :config
       (add-to-list 'auto-mode-alist '("\\.cs\\'" . csharp-mode))
       (add-to-list 'eglot-server-programs '(csharp-mode "omnisharp" "-lsp" "-stdio")))
   #+end_src

** Smooth scrolling
    #+begin_src emacs-lisp
      (leaf smooth-scrolling
        :custom (smooth-scroll-margin . 5)
        :config
        (smooth-scrolling-mode 1))
    #+end_src

** Completion
*** Corfu
   #+begin_src emacs-lisp
     (leaf corfu
       :setq
       (corfu-auto . t)
       (corfu-quit-no-match . t)
       :config
       (global-corfu-mode))
   #+end_src

*** Vertico
    #+begin_src emacs-lisp
      (leaf vertico
        :require (t vertico-directory)
        :bind
        (:vertico-map
         ("RET" . vertico-directory-enter)
         ("DEL" . vertico-directory-delete-char))
        :hook (rfn-eshadow-update-overlay-hook . vertico-directory-tidy)
        :config
        (vertico-mode))

      (leaf orderless
        :setq
        (completion-styles . '(basic orderless))
        (completion-category-defaults . nil)
        (completion-category-overrides . '((file (styles partial-completion)))))
    #+end_src

*** Marginalia (information in completion annotations)
    #+begin_src emacs-lisp
      (leaf marginalia
        :bind (:minibuffer-local-map
               ("M-A" . marginalia-cycle))
        :config
        (marginalia-mode))
    #+end_src

** Magit
   #+begin_src emacs-lisp
     ; (leaf magit)
   #+end_src

** Beacon mode
   Highlights the cursor when the window scrolls, on focus, etc.
   #+begin_src emacs-lisp
     (leaf beacon
       :custom
       ((beacon-blink-when-focused . t)
        (beacon-blink-when-point-moves-vertically . 10)
        (beacon-blink-duration . 0.4)
        (beacon-blink-delay . 0.3)
        (beacon-size . 20)
        (beacon-dont-blink-modes ))
       :config
       (push 'ibuffer-mode beacon-dont-blink-major-modes)
       (push 'sly-mrepl-mode beacon-dont-blink-major-modes)
       (beacon-mode 1))
   #+end_src

** Telegram
   #+begin_src emacs-lisp
     (leaf telega
       :init
       (setq telega-directory (expand-file-name "~/.local/share/telega/"))
       :pre-setq
       (telega-use-images . t)
       (telega-emoji-font-family . "Apple Color Emoji")
       (telega-emoji-use-images . t)
       :setq
       (telega-animation-play-inline . 2)
       :config
       (define-key global-map (kbd "C-c t") telega-prefix-map))
   #+end_src

* Key mappings
  #+begin_src emacs-lisp
    (defalias 'yes-or-no-p 'y-or-n-p)

    (defun my/tab-insert-command ()
      (interactive)
      (insert "	"))

    (defun my/nop () (interactive) nil)

    (my/global-set-keys
      ("C-x b" 'ibuffer)
      ("C-x C-b" 'ido-switch-buffer)
      ("C-x k" 'kill-current-buffer)
      ("C-c q" 'delete-window)
      ("C-c a" 'org-agenda)
      ("C-<tab>" 'my/tab-insert-command)
      ("M-ESC" 'my/nop))

    (define-key isearch-mode-map (kbd "M-ESC") 'my/nop)
  #+end_src

** Config visit/reload
  #+begin_src emacs-lisp
    (defun config-visit ()
      "Find config.org"
      (interactive)
      (find-file "~/.emacs.d/config.org"))

    (defun config-reload ()
      "Reload the configuration file"
      (interactive)
      (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))
    (global-set-key (kbd "C-c r") 'config-reload)
    (global-set-key (kbd "C-c e") 'config-visit)
  #+end_src

* Org mode
** Org contrib
   #+begin_src emacs-lisp
     (leaf org-contrib)
   #+end_src

** Emacs lisp code blocks with <el TAB
   #+begin_src emacs-lisp
     (add-to-list 'org-modules 'org-tempo)
     (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
   #+end_src

** For latex export
   Packages for:
   - different langauges;
   - code snippets
   - titling
   - xelatex graphics
   - spacing adjustment
   - font choice
   - geometry manipulation
   - paragraph spacing

   #+begin_src emacs-lisp
     (add-to-list 'org-latex-packages-alist '("AUTO" "babel" t ("xelatex" "pdflatex")))
     (add-to-list 'org-latex-packages-alist '("cache=false" "minted" t ("xelatex")))
     (add-to-list 'org-latex-packages-alist '("" "titling" t ("xelatex" "pdflatex")))
     (add-to-list 'org-latex-packages-alist '("" "graphicx" t ("xelatex")))
     (add-to-list 'org-latex-packages-alist '("" "setspace" t ("xelatex")))
     (add-to-list 'org-latex-packages-alist '("" "fontspec" t ("xelatex")))
     (add-to-list 'org-latex-packages-alist '("margin=2.5cm" "geometry" t ("xelatex")))
     (add-to-list 'org-latex-packages-alist (list "" "parskip" t org-latex-compilers))

     (setq
      org-latex-title-command nil
      org-latex-listings 'minted
      org-latex-compiler "xelatex"
      org-latex-pdf-process
      '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f")
      org-latex-minted-options '(("breaklines" "true") ("breakanywhere" "true")
                 ("breaksymbolleft" "\\null"))
      )
   #+end_src

** Adapt indentation to outline node level
   #+begin_src emacs-lisp
     (setq org-adapt-indentation t)
   #+end_src

** Agenda
   #+begin_src emacs-lisp
     (setq org-agenda-files (file-expand-wildcards "~/.emacs.d/org/agenda/*.org"))
   #+end_src

** Org bullets
   #+begin_src emacs-lisp
     (leaf org-bullets
       :custom
       ;; Default: '("◉" "○" "✸" "✿")
       ;; Second:  '("*" "●" "○" "·")
       ;; Third:   '("●" "*" "•" "·")
       ;; ♥ ● ◇ ✚ ✜ ☯ ◆ ♠ ♣ ♦ ☢ ❀ ◆ ◖ ▶
       ;; ►  ★ ▸
       (org-bullets-bullet-list . '("●" "*" "•" "·"))
       :hook (org-mode-hook . org-bullets-mode))
   #+end_src

** Auto save buffers
   #+begin_src emacs-lisp
     (advice-add 'org-agenda-quit :before 'org-save-all-org-buffers)
   #+end_src

** Org capture disable the dumb bookmark
   #+begin_src emacs-lisp
     (setq org-capture-bookmark nil)
   #+end_src

** Org src should appear in the same window instead of splitting
    #+begin_src emacs-lisp
      (setq org-src-window-setup 'current-window)
    #+end_src

** Org roam
   #+begin_src emacs-lisp
     (leaf org-roam
       :init
       (setq org-roam-v2-ack t)
       :custom
       (org-roam-complete-everywhere . t)
       :bind (("C-c n l" . org-roam-buffer-toggle)
              ("C-c n f" . org-roam-node-find)
              ("C-c n i" . org-roam-node-insert)
              ("C-c n g" . org-roam-graph)
              ("C-c n c" . org-roam-capture)
              ;; Dailies
              ("C-c n j" . org-roam-dailies-capture-today)
              (:org-mode-map
               ("C-M-i"  . completion-at-point)))
       :config
       (setq org-roam-directory (file-truename "~/.emacs.d/org/roam/"))
       (org-roam-setup))
   #+end_src

* Preferences
** Unfill region
   #+begin_src emacs-lisp
     (defun unfill-region (beg end)
       "Unfill the region, joining text paragraphs into a single
         logical line.  This is useful, e.g., for use with
         `visual-line-mode'."
       (interactive "*r")
       (let ((fill-column (point-max)))
         (fill-region beg end)))
   #+end_src

** Common Lisp Hyperspec setup
   #+begin_src emacs-lisp
     (setq common-lisp-hyperspec-root (concat "file:///" (expand-file-name "~/.emacs.d/clhs/")))
     (defun my/eww-browser-bind-advice (original-function &rest args)
       "Binds EWW as the local browser to do whatever browsing is required."
       (setq-local browse-url-browser-function 'eww-browse-url)
       (apply original-function args))
     (advice-add 'hyperspec-lookup :around #'my/eww-browser-bind-advice)
   #+end_src

** Emacs shouldn't open pdf files
   #+begin_src emacs-lisp
     (customize-set-variable 'org-file-apps
       '(("\\.pdf\\'" . "xdg-open %s")
         (auto-mode . emacs)
         (directory . default)
         ("\\.mm\\'" . default)
         ("\\.x?html?\\'" . default)))
   #+end_src

** Indentation
   #+begin_src emacs-lisp
     (setq css-indent-offset 2)
   #+end_src

** Font Lock support mode
   #+begin_src emacs-lisp
     (setq font-lock-support-mode #'jit-lock-mode)
   #+end_src

** Auto hide compilation buffer
   #+begin_src emacs-lisp
     (defun my/auto-hide-compilation-window (buf str)
       (when (null (string-match ".*exited abnormally.*" str))
         (let ((win (get-buffer-window buf 'visible)))
           (when win (delete-window win)))))

     (add-hook 'compilation-finish-functions 'my/auto-hide-compilation-window)
   #+end_src

** Select the help window when opening it
   #+begin_src emacs-lisp
     (setq help-window-select t)
   #+end_src

** Backup files, lock files and auto saving
    #+begin_src emacs-lisp
      (setq make-backup-files nil
            auto-save-default nil
            create-lockfiles  nil)
    #+end_src

** Hide startup screen
    #+begin_src emacs-lisp
      (setq inhibit-startup-screen t)
    #+end_src

** Show matching parentheses
    #+begin_src emacs-lisp
      (setq show-paren-delay 0)
      (show-paren-mode 1)
    #+end_src

** Add newline at the end of file
    #+begin_src emacs-lisp
      (setq require-final-newline t)
    #+end_src

** Display column numbers
    #+begin_src emacs-lisp
      (setq column-number-mode t)
    #+end_src

** Window splitting config
   Redefined =split-window-sensibly= to prefer splitting windows vertically
    #+begin_src emacs-lisp
      (defun split-window-sensibly (&optional window)
        "Modified by >>ME<< to prefer splitting windows vertically

      Split WINDOW in a way suitable for `display-buffer'.
      WINDOW defaults to the currently selected window.
      If `split-width-threshold' specifies an integer, WINDOW is at
      least `split-width-threshold' columns wide and can be split
      horizontally, split WINDOW into two windows side by side and
      return the lower window.  Otherwise, if `split-height-threshold'
      specifies an integer, WINDOW is at least `split-height-threshold'
      lines tall and can be split vertically, split WINDOW into two
      windows side by side and return the window on the right.  If this
      can't be done either and WINDOW is the only window on its frame,
      try to split WINDOW vertically disregarding any value specified
      by `split-height-threshold'.  If that succeeds, return the lower
      window.  Return nil otherwise.

      By default `display-buffer' routines call this function to split
      the largest or least recently used window.  To change the default
      customize the option `split-window-preferred-function'.

      You can enforce this function to not split WINDOW horizontally,
      by setting (or binding) the variable `split-width-threshold' to
      nil.  If, in addition, you set `split-height-threshold' to zero,
      chances increase that this function does split WINDOW vertically.

      In order to not split WINDOW vertically, set (or bind) the
      variable `split-height-threshold' to nil.  Additionally, you can
      set `split-width-threshold' to zero to make a horizontal split
      more likely to occur.

      Have a look at the function `window-splittable-p' if you want to
      know how `split-window-sensibly' determines whether WINDOW can be
      split."
        (let ((window (or window (selected-window))))
          (or (and (window-splittable-p window t)
                   (with-selected-window window
                     (split-window-right)))
              (and (window-splittable-p window)
                   (with-selected-window window
                     (split-window-below)))
              (and
               ;; If WINDOW is the only usable window on its frame (it is
               ;; the only one or, not being the only one, all the other
               ;; ones are dedicated) and is not the minibuffer window, try
               ;; to split it vertically disregarding the value of
               ;; `split-height-threshold'.
               (let ((frame (window-frame window)))
                 (or
                  (eq window (frame-root-window frame))
                  (catch 'done
                    (walk-window-tree (lambda (w)
                                        (unless (or (eq w window)
                                                    (window-dedicated-p w))
                                          (throw 'done nil)))
                                      frame nil 'nomini)
                    t)))
               (not (window-minibuffer-p window))
               (let ((split-height-threshold 0))
                 (when (window-splittable-p window)
                   (with-selected-window window
                     (split-window-below))))))))

      (setq split-width-threshold 120)
    #+end_src

** Don't confirm killing processes
    #+begin_src emacs-lisp
      (setq confirm-kill-process nil)
    #+end_src

** Disable tab indentation
    #+begin_src emacs-lisp
      (setq-default indent-tabs-mode nil)
    #+end_src

** Tab width
    #+begin_src emacs-lisp
      (setq-default tab-width 4)
    #+end_src

** Don't wrap lines
    #+begin_src emacs-lisp
      (setq-default truncate-lines t)
    #+end_src

** Fill column
    #+begin_src emacs-lisp
      (setq-default fill-column 80)
    #+end_src

** C language indentation
    #+begin_src emacs-lisp
      (setq-default c-default-style '((c-mode . "bsd"))
                    c-basic-offset tab-width
                    cperl-indent-level tab-width)
    #+end_src

** Reserve space for line numbers
    #+begin_src emacs-lisp
    (setq-default display-line-numbers-width 3)
    #+end_src

** Open =.cl= files as lisp files
  #+begin_src emacs-lisp
    (add-to-list 'auto-mode-alist '("\\.cl\\'" . lisp-mode))
  #+end_src

** Fringes
   #+begin_src emacs-lisp
     (fringe-mode '(2 . 0))
   #+end_src

** Ibuffer
*** Expert mode (no confirmations)
    #+begin_src emacs-lisp
      (setq ibuffer-expert t)
    #+end_src

*** Filter groups
   #+begin_src emacs-lisp
     (setq ibuffer-saved-filter-groups
           '(("default"
              ("lisp" (or
                       (mode . lisp-mode)
                       (mode . scheme-mode)
                       (mode . emacs-lisp-mode)))
              ("org" (or (mode . org-mode)
                         (name . "\\*Org Src.*\\*")))
              ("emacs" (or
                        (name . "^\\*scratch\\*$")
                        (name . "^\\*Messages\\*$")))
              ("trashcan" (or
                           (name . "^\\*straight-process\\*$")
                           (name . "^\\*Compile-Log\\*$")
                           (name . "^\\*inferior-lisp\\*$")
                           (name . "^\\*slime-events\\*$"))))))
   #+end_src

** Disable the scroll bar, menu bar and the tool bar
   #+begin_src emacs-lisp
     (scroll-bar-mode -1)
     (menu-bar-mode -1)
     (tool-bar-mode -1)
   #+end_src

** Cursor
   Blinking box.
   #+begin_src emacs-lisp
     (blink-cursor-mode)
     (setq-default cursor-type t)
   #+end_src

** Whitespace
   #+begin_src emacs-lisp
     (setq whitespace-style '(face tabs tab-mark)
           whitespace-display-mappings '((tab-mark 9 [8250 9] [92 9])
                                         (space-mark 32 [183] [46])))
   #+end_src

** Have custom in a separate file (=.emacs.d/custom.el=)
   #+begin_src emacs-lisp
     (setq custom-file "~/.emacs.d/custom.el")
     (load "~/.emacs.d/custom.el")
   #+end_src

** Completion buffer popping up
   #+begin_src emacs-lisp
     (setq completion-auto-help 'lazy)
   #+end_src

** Scroll current line only
   #+begin_src emacs-lisp
     (setq truncate-lines t)
     (setq-default auto-hscroll-mode 'current-line)
   #+end_src

* Hooks
  #+begin_src emacs-lisp
    (my/add-hooks
      ((lisp-mode-hook scheme-mode-hook emacs-lisp-mode-hook)
         (setq tab-width         my/indent-offset
               indent-tabs-mode  nil
               fill-column       100)
         (paren-face-mode))
      (before-save-hook
         (unless (eq major-mode 'markdown-mode)
           (delete-trailing-whitespace)))
      (org-mode-hook
         (auto-fill-mode))
      ((text-mode-hook org-mode-hook prog-mode-hook)
         (display-fill-column-indicator-mode)
         (whitespace-mode))
      (ibuffer-mode-hook
         (ibuffer-switch-to-saved-filter-groups "default"))
      (sly-mode-hook
         (paren-face-mode))
      (sly-mrepl-mode-hook
         (delete-other-windows)
         (visual-line-mode))
      ((help-mode-hook sly-db-mode-hook)
         (visual-line-mode))
      (whitespace-mode-hook
         (set-face-attribute 'whitespace-tab nil :background (face-attribute 'default :background)))
      (css-mode-hook
         (electric-pair-local-mode)))
   #+end_src
